using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Vox3D
{ 
    public class World : MonoBehaviour, IInitializable
    {
        private bool _Initialized = false;

        private int _WorldSize;                     // Property taken from WorldProperties. We save it locally to avoid continuous Instance calls
        private int _ChunkSize;                     // Property taken from WorldProperties. We save it locally to avoid continuous Instance calls
        private int _VoxelSize;                     // Property taken from WorldProperties. We save it locally to avoid continuous Instance calls

        private Dictionary<Vector3, Chunk> _Chunks; // Dictionary holding chunks. Uses their world-space position as key, in order to easily reference them

        private HeightMap2D _HeightMap;             // Holds the map generated by a given noise source. The map acts as the lookup table for voxel elevation

        public bool Initialized                     { get => _Initialized; set => _Initialized = value; }
        public int WorldSize                        { get => _WorldSize; set => _WorldSize = value; }
        public int ChunkSize                        { get => _ChunkSize; set => _ChunkSize = value; }
        public int VoxelSize                        { get => _VoxelSize; set => _VoxelSize = value; }
        public Dictionary<Vector3, Chunk> Chunks    { get => _Chunks; set => _Chunks = value; }
        public HeightMap2D HeightMap                { get => _HeightMap; set => _HeightMap = value; }

        /// <summary>
        /// Method used to set basic parameters for world and heightmap generation. 
        /// Initial parameters are obtained from the Vox3DProperties in the manager instance.
        /// </summary>
        /// <returns></returns>
        public bool TryInitialize()
        {
            var manager     = Vox3DManager.Instance();
            var properties  = manager.Properties;

            if(properties is null)
            {
                Debug.LogWarning("Vox3DProperties is null. Unable to initialize world.");
                return false;
            }

            if (manager.NoiseSource is null)
            {
                Debug.LogWarning("NoiseSource is null. Unable to initialize world.");
                return false;
            }

            // Set basic parameters for world generation

            _WorldSize  = properties.WorldSize;
            _ChunkSize  = properties.ChunkSize;
            _VoxelSize  = properties.VoxelSize;

            Chunks      = new Dictionary<Vector3, Chunk>();

            // Set basic parameters for heightmap generation

            int width   = WorldSize * ChunkSize;
            int height  = WorldSize * ChunkSize;
            var source  = manager.NoiseSource;
            HeightMap   = new HeightMap2D(width, height, 0.0f, source);

            Initialized = true;

            return Initialized;
        }
        public void PopulateWorld()
        {
            if (!Initialized)
            {
                Debug.LogWarning($"Unable to populate chunk dictionary for world {name}. World was not initialized correctly.");
                return;
            }

            if(Chunks.Count > 0)
            {
                Debug.LogWarning($"Chunk dictionary is not empty. Ensure dictionary is empty before calling PopulateChunks().");
                return;
            }

            for (int x = 0; x < WorldSize; x++)
            {
                for (int y = 0; y < WorldSize; y++)
                {
                    for (int z = 0; z < WorldSize; z++)
                    {
                        // Ensure that each chunk takes into account both the size of the chunks and the size of the voxels
                        int worldScale = ChunkSize * VoxelSize;

                        Vector3 chunkPosition   = new Vector3(x, y, z) * worldScale;
                        GameObject chunkObject  = new GameObject($"Chunk_{x}_{y}_{z}");

                        chunkObject.transform.position  = chunkPosition;
                        chunkObject.transform.parent    = this.transform;

                        Chunk chunk = chunkObject.AddComponent<Chunk>();

                        chunk.MeshFilter    = chunkObject.AddComponent<MeshFilter>();
                        chunk.MeshRenderer  = chunkObject.AddComponent<MeshRenderer>();
                        chunk.MeshCollider  = chunkObject.AddComponent<MeshCollider>();

                        chunk.ChunkSize     = ChunkSize;
                        chunk.VoxelSize     = VoxelSize;
                        chunk.Voxels        = new Voxel[ChunkSize, ChunkSize, ChunkSize];

                        chunk.Vertices      = new List<Vector3>();
                        chunk.Indices       = new List<int>();
                        chunk.Uvs           = new List<Vector2>();

                        Chunks.Add(chunkPosition, chunk);

                    }
                }
            }

        }
        public void PopulateChunks()
        {
            if (!Initialized)
            {
                Debug.LogWarning($"Unable to populate chunks for world {name}. World was not initialized correctly.");
                return;
            }

            foreach (var entry in Chunks)
            {
                PriorityCallStack.Instance().Push(() => entry.Value.PopulateChunk(), 0);
            }
        }
        public void GenerateGeometry()
        {
            foreach (KeyValuePair<Vector3, Chunk> pair in Chunks)
            {
                PriorityCallStack.Instance().Push(() => pair.Value.GenerateGeometry_Greedy(), 0);
            }

        }
        public void PurgeWorld()
        {
            foreach (KeyValuePair<Vector3, Chunk> pair in Chunks)
            {
                pair.Value.PurgeChunk();
                Destroy(pair.Value.gameObject);
            }

            Chunks.Clear();
        }

        /// <summary>
        /// Checks whether point is within a chunk.
        /// If it is, the chunk is returned.
        /// </summary>
        /// <param name="point">point in world space</param>
        /// <returns></returns>
        public Chunk GetChunkAt(Vector3 point)
        {
            if (!Initialized)
            {
                Debug.LogWarning($"Unable to find chunk at {point} for world {name}. World was not initialized correctly.");
                return null;
            }

            if(Chunks.Count == 0)
            {
                Debug.LogWarning($"Chunks dictionary was empty for world {name}. Ensure dictionary is populated before calling GetChunkAt().");
                return null;
            }

            // Calculate the chunk's precise position by eliminating floating point values
            Vector3Int chunkCoordinates = new Vector3Int(
                Mathf.FloorToInt(point.x / (ChunkSize * VoxelSize)) * (ChunkSize * VoxelSize),
                Mathf.FloorToInt(point.y / (ChunkSize * VoxelSize)) * (ChunkSize * VoxelSize),
                Mathf.FloorToInt(point.z / (ChunkSize * VoxelSize)) * (ChunkSize * VoxelSize)
            );

            // Retrieve and return the chunk at the calculated position within the dictionary
            if (Chunks.TryGetValue(chunkCoordinates, out Chunk chunk))
            {
                return chunk;
            }

            // Return null if no chunk exists at the position
            return null;
        }


    }

}
