using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Vox3D
{ 
    //TODO detach chunk/voxel/geometry generation from unity monobehaviour functions
    public class World : MonoBehaviour
    {
        private int _WorldSize;                     // Property taken from WorldProperties. We save it locally to avoid continuous Instance calls
        private int _ChunkSize;                     // Property taken from WorldProperties. We save it locally to avoid continuous Instance calls
        private int _VoxelSize;                     // Property taken from WorldProperties. We save it locally to avoid continuous Instance calls

        private Dictionary<Vector3, Chunk> _Chunks; // Dictionary holding chunks. Uses their world-space position as key, in order to easily reference them

        private HeightMap2D _HeightMap;             // Holds the map generated by a given noise source. The map acts as the lookup table for voxel elevation

        public int WorldSize                        { get => _WorldSize; set => _WorldSize = value; }
        public int ChunkSize                        { get => _ChunkSize; set => _ChunkSize = value; }
        public int VoxelSize                        { get => _VoxelSize; set => _VoxelSize = value; }
        public Dictionary<Vector3, Chunk> Chunks    { get => _Chunks; set => _Chunks = value; }
        public HeightMap2D HeightMap                { get => _HeightMap; set => _HeightMap = value; }

        private void Start()
        {
            var properties = Vox3DProperties.Instance();

            if (!properties.IsReady())
            {
                Debug.LogWarning("WorldProperties not loaded after world creation");
                return;
            }

            WorldSize = properties.WorldSize;
            ChunkSize = properties.ChunkSize;
            VoxelSize = properties.VoxelSize;

            Chunks = new Dictionary<Vector3, Chunk>();

            if(HeightMap is null)
            {
                Debug.LogWarning("HeightMap not set for world. Chunks will not be generated on Start.");
                return;
            }
            else PopulateWorld();
        }

        public void PopulateWorld()
        {
            Debug.Log("POPULATING WORLD " + name);

            for (int x = 0; x < WorldSize; x++)
            {
                for (int y = 0; y < WorldSize; y++)
                {
                    for (int z = 0; z < WorldSize; z++)
                    {
                        // Ensure that each chunk takes into account both the size of the chunks and the size of the voxels
                        int worldScale = ChunkSize * VoxelSize;

                        Vector3 chunkPosition   = new Vector3(x, y, z) * worldScale;
                        GameObject chunkObject  = new GameObject($"Chunk_{x}_{y}_{z}");

                        chunkObject.transform.position  = chunkPosition;
                        chunkObject.transform.parent    = this.transform;

                        Chunk chunk         = chunkObject.AddComponent<Chunk>();

                        chunk.MeshFilter    = chunkObject.AddComponent<MeshFilter>();
                        chunk.MeshRenderer  = chunkObject.AddComponent<MeshRenderer>();
                        chunk.MeshCollider  = chunkObject.AddComponent<MeshCollider>();

                        chunk.ChunkSize     = ChunkSize;
                        chunk.VoxelSize     = VoxelSize;
                        chunk.Voxels        = new Voxel[ChunkSize, ChunkSize, ChunkSize];

                        chunk.Vertices      = new List<Vector3>();
                        chunk.Indices       = new List<int>();
                        chunk.Uvs           = new List<Vector2>();

                        // Create voxels within the new chunk. No geometry.
                        chunk.PopulateChunk();

                        Chunks.Add(chunkPosition, chunk);

                    }
                }
            }

            GenerateGeometry();

        }

        public void GenerateGeometry()
        {
            Debug.Log("GENERATING WORLD GEOMETRY " + name);

            foreach(KeyValuePair<Vector3, Chunk> pair in Chunks)
            {
                pair.Value.GenerateGeometry_Greedy();
            }

        }

        /// <summary>
        /// Checks whether point is within a chunk.
        /// If it is, the chunk is returned.
        /// </summary>
        /// <param name="point">point in world space</param>
        /// <returns></returns>
        public Chunk GetChunkAt(Vector3 point)
        {
            // Calculate the chunk's precise position by eliminating floating point values
            Vector3Int chunkCoordinates = new Vector3Int(
                Mathf.FloorToInt(point.x / (ChunkSize * VoxelSize)) * (ChunkSize * VoxelSize),
                Mathf.FloorToInt(point.y / (ChunkSize * VoxelSize)) * (ChunkSize * VoxelSize),
                Mathf.FloorToInt(point.z / (ChunkSize * VoxelSize)) * (ChunkSize * VoxelSize)
            );

            // Retrieve and return the chunk at the calculated position within the dictionary
            if (Chunks.TryGetValue(chunkCoordinates, out Chunk chunk))
            {
                return chunk;
            }

            // Return null if no chunk exists at the position
            return null;
        }

        public void PurgeWorld()
        {
            foreach (KeyValuePair<Vector3, Chunk> pair in Chunks)
            {
                pair.Value.PurgeChunk();
                Destroy(pair.Value.gameObject);
            }

            Chunks.Clear();
        }

    }

}
