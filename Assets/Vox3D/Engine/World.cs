using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Vox3D
{
    public class World : MonoBehaviour
    {
        private int _worldSize;                     // Property taken from WorldProperties. We save it locally to avoid continuous Instance calls
        private int _chunkSize;                     // Property taken from WorldProperties. We save it locally to avoid continuous Instance calls
        private int _voxelSize;                     // Property taken from WorldProperties. We save it locally to avoid continuous Instance calls

        private Dictionary<Vector3, Chunk> _chunks; // Dictionary holding chunks. Uses their world-space position as key, in order to easily reference them

        private HeightMap2D _heightMap;             // Holds the map generated by a given noise source. The map acts as the lookup table for voxel elevation

        public int WorldSize                        { get => _worldSize; set => _worldSize = value; }
        public int ChunkSize                        { get => _chunkSize; set => _chunkSize = value; }
        public int VoxelSize                        { get => _voxelSize; set => _voxelSize = value; }
        public Dictionary<Vector3, Chunk> Chunks    { get => _chunks; set => _chunks = value; }
        public HeightMap2D HeightMap                { get => _heightMap; set => _heightMap = value; }

        private void Start()
        {
            var properties = Vox3DProperties.Instance();

            if (!properties.IsReady())
            {
                Debug.LogWarning("WorldProperties not loaded after world creation");
                return;
            }

            WorldSize = properties.WorldSize;
            ChunkSize = properties.ChunkSize;
            VoxelSize = properties.VoxelSize;

            Chunks = new Dictionary<Vector3, Chunk>();

            if(HeightMap is null)
            {
                Debug.LogWarning("HeightMap not set for world. Chunks will not be generated on Start.");
                return;
            }
            else PopulateWorld();
        }

        public void PopulateWorld()
        {
            Debug.Log("POPULATING WORLD " + name);

            for (int x = 0; x < WorldSize; x++)
            {
                for (int y = 0; y < WorldSize; y++)
                {
                    for (int z = 0; z < WorldSize; z++)
                    {
                        // Ensure that each chunk takes into account both the size of the chunks and the size of the voxels
                        int worldScale = ChunkSize * VoxelSize;

                        Vector3 chunkPosition   = new Vector3(x, y, z) * worldScale;
                        GameObject chunkObject  = new GameObject($"Chunk_{x}_{y}_{z}");

                        chunkObject.transform.position  = chunkPosition;
                        chunkObject.transform.parent    = this.transform;

                        Chunk chunk         = chunkObject.AddComponent<Chunk>();

                        chunk.MeshFilter    = chunkObject.AddComponent<MeshFilter>();
                        chunk.MeshRenderer  = chunkObject.AddComponent<MeshRenderer>();
                        chunk.MeshCollider  = chunkObject.AddComponent<MeshCollider>();

                        chunk.ChunkSize     = ChunkSize;
                        chunk.VoxelSize     = VoxelSize;
                        chunk.Voxels        = new Voxel[ChunkSize, ChunkSize, ChunkSize];

                        chunk.Vertices      = new List<Vector3>();
                        chunk.Indices       = new List<int>();
                        chunk.Uvs           = new List<Vector2>();

                        // Create voxels within the new chunk. No geometry.
                        chunk.PopulateChunk();

                        Chunks.Add(chunkPosition, chunk);

                    }
                }
            }

            GenerateGeometry();

        }

        public void GenerateGeometry()
        {
            Debug.Log("GENERATING WORLD GEOMETRY " + name);

            foreach(KeyValuePair<Vector3, Chunk> pair in Chunks)
            {
                pair.Value.GenerateGeometry_Greedy();
            }

        }

        public Chunk GetChunkAt(Vector3 worldSpaceChunkPosition)
        {
            // Calculate the chunk's precise position by eliminating floating point values
            Vector3Int chunkCoordinates = new Vector3Int(
                Mathf.FloorToInt(worldSpaceChunkPosition.x / (ChunkSize * VoxelSize)) * (ChunkSize * VoxelSize),
                Mathf.FloorToInt(worldSpaceChunkPosition.y / (ChunkSize * VoxelSize)) * (ChunkSize * VoxelSize),
                Mathf.FloorToInt(worldSpaceChunkPosition.z / (ChunkSize * VoxelSize)) * (ChunkSize * VoxelSize)
            );

            // Retrieve and return the chunk at the calculated position within the dictionary
            if (Chunks.TryGetValue(chunkCoordinates, out Chunk chunk))
            {
                return chunk;
            }

            // Return null if no chunk exists at the position
            return null;
        }



    }

}


// TODO write methods to generate/refresh geometry and colliders